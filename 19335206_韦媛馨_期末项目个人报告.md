#                       计算机图形学项目报告

|   实验    |     FinalProject      | 专业（方向） | 计算机科学与技术（超算方向） |
| :-------: | :-------------------: | :----------: | :--------------------------: |
| **学号**  |     **19335206**      |   **姓名**   |          **韦媛馨**          |
| **Email** | **3366875159@qq.com** | **完成日期** |         **2022/1/5**         |





### 1. 个人工作

在这次小组合作的项目中，我主要负责天空盒的绘制，并实现旋转，产生在太阳系身临其境的感觉，增加了场景真实性。



### 2. 实现过程

#### 2.1 天空盒

[立方体贴图 - LearnOpenGL CN (learnopengl-cn.github.io)](https://learnopengl-cn.github.io/04 Advanced OpenGL/06 Cubemaps/#_4)

##### 2.1.1  实现思路

天空盒是一个包含了整个场景的立方体，它包含周围环境的6个图像，会产生以为处在一个比实际大得多的环境当中的感觉。实验中天空盒使用立方体贴图来实现：绘制有一个6面的立方体，每个面都需要一个纹理。因为太阳系的场景中并没有很明显的上下左右前后六个面区分，因此六个面都使用同一个贴图`sky.png`：

<img src=".\figures\p6.png" alt="image-20220103145938935" style="zoom: 33%;" />



##### 2.1.2 关键代码

天空盒的绘制是封装了一个类`Skybox`来实现的。由于天空盒是绘制在一个立方体上的，和其它物体一样需要另一个VAO、VBO以及一组顶点，此外还需要相应的纹理和着色器：

```c
class Skybox {
public:
	Skybox(QWidget* widget);
	~Skybox();
	void drawSkybox(QMatrix4x4 model, QMatrix4x4 projection);
	void init();
	
private:
	QVector<float> SkyboxVertices;
	QOpenGLVertexArrayObject SkyboxVAO;	// 顶点数组对象
	QOpenGLBuffer SkyboxVBO;	// 顶点缓冲对象
	QOpenGLTexture SkyboxTexture;	// 纹理
	QOpenGLShaderProgram shaderProgram; //着色器

};
```



顶点着色器如下：

```c
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 2) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
 
void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}
```

片元着色器如下，最后的`vec4(0.8f,0.77f,0.45f,0.7f)`是调整天空盒的亮度和颜色：

```c
#version 330 core
out vec4 FragColor;

in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D ourTexture;

void main()
{
    FragColor = texture(ourTexture, TexCoord) * vec4(0.8f,0.77f,0.45f,0.7f);
}     
```



在构造函数中，对`SkyboxVertices`初始化如下。它的绘制思路很简单，逐一确定正方体的六个面，再传递颜色参数和纹理坐标的位置，其中颜色的参数是在上面的着色器中进行计算后显示出来，下面的代码只展示了顶面顶点初始化：

```c
Skybox::Skybox(QWidget* widget) :
	SkyboxVBO(QOpenGLBuffer::VertexBuffer),
	SkyboxTexture(QOpenGLTexture::Target2D)
{

SkyboxVertices = {
		// 位置                                      // 颜色		   // 纹理
1.0f *sky_size, -1.0f * sky_size, 1.0f * sky_size,1.0f, 1.0f, 1.0f,1.0f, 0.0f, // 右下
1.0f *sky_size, -1.0f * sky_size, 1.0f * sky_size,1.0f, 1.0f, 1.0f,0.0f, 0.0f, // 左下
1.0f *sky_size,  1.0f * sky_size, 1.0f * sky_size,1.0f, 1.0f, 1.0f,0.0f, 1.0f, // 左下
1.0f *sky_size,  1.0f * sky_size, 1.0f * sky_size,1.0f, 1.0f, 1.0f,1.0f, 1.0f, // 右上
		...
	};
}
```



想要调用天空盒绘制，需要先在`MyGLWidget::initializeGL()`中调用`skybox.init()`进行初始化，之后在`MyGLWidget::scene_0()`中是这么调用的：

```c
QMatrix4x4 model;
model.setToIdentity();
QMatrix4x4 projection;
projection.perspective(45.0f, width() / (float)height(), 0.1f, 1000.0f);
skybox.drawSkybox(model, projection);
```

天空盒的初始化函数如下：

```c
void Skybox::init() {
	if (!shaderProgram.addShaderFromSourceFile(QOpenGLShader::Vertex, ":/resource/shaders/triangle.vert")) {     //添加并编译顶点着色器
		qDebug() << "ERROR:" << shaderProgram.log();    // 编译出错时打印报错信息
	}
	if (!shaderProgram.addShaderFromSourceFile(QOpenGLShader::Fragment, ":/resource/shaders/triangle.frag")) {   //添加并编译片段着色器
		qDebug() << "ERROR:" << shaderProgram.log();    // 编译出错时打印报错信息
	}
	if (!shaderProgram.link()) {						// 链接着色器
		qDebug() << "ERROR:" << shaderProgram.log();    // 编译出错时打印报错信息
	}

	SkyboxVAO.create();       // 生成VAO对象
	SkyboxTexture.create();

	SkyboxTexture.setData(QImage(":/resource/textures/sky.png").mirrored());
	SkyboxTexture.setWrapMode(QOpenGLTexture::DirectionS, QOpenGLTexture::Repeat);
	SkyboxTexture.setWrapMode(QOpenGLTexture::DirectionT, QOpenGLTexture::Repeat);

	SkyboxTexture.setMinMagFilters(QOpenGLTexture::Nearest, QOpenGLTexture::Linear);
	SkyboxTexture.setMinMagFilters(QOpenGLTexture::LinearMipMapLinear, QOpenGLTexture::Linear);
}
```



绘制天空盒的函数如下：

```c
void Skybox::drawSkybox(QMatrix4x4 model, QMatrix4x4 projection) {
	shaderProgram.bind();
	float time = QTime::currentTime().msecsSinceStartOfDay() / 1000.0;
	model.rotate(10 * time, QVector3D(1.0f, 0.0f, -1.0f));//天空盒旋转

	QMatrix4x4 view;
	shaderProgram.setUniformValue("view", view);
	shaderProgram.setUniformValue("projection", projection);
	shaderProgram.setUniformValue("model", model);

	SkyboxVAO.bind();
	SkyboxVBO.create();       // 生成VBO对象
	SkyboxVBO.bind();         // 将VBO绑定到当前的顶点缓冲对象
	SkyboxVBO.allocate(SkyboxVertices.data(), sizeof(float) * SkyboxVertices.size());

	shaderProgram.setAttributeBuffer(0, GL_FLOAT, 0, 3, sizeof(GLfloat) * 8);
	shaderProgram.enableAttributeArray(0);
	shaderProgram.setAttributeBuffer(1, GL_FLOAT, sizeof(GLfloat) * 3, 3, sizeof(GLfloat) * 8);
	shaderProgram.enableAttributeArray(1);
	shaderProgram.setAttributeBuffer(2, GL_FLOAT, sizeof(GLfloat) * 6, 2, sizeof(GLfloat) * 8);
	shaderProgram.enableAttributeArray(2);

	SkyboxTexture.bind(0);
	shaderProgram.setUniformValue("ourTexture", 0);// 让着色采样器从纹理单元0中获取纹理数据

	glDrawArrays(GL_QUADS, 0, 24);
	SkyboxVAO.release();
	SkyboxTexture.release();
	shaderProgram.release();
}
```



### 3. 实验结果

最终呈现的是一个沿着一定方向转动的天空盒：

<img src=".\figures\p7.png" alt="image-20220104205208012" style="zoom: 33%;" />



### 4. 遇到的困难

1. 立方体贴图的边界会比较明显：

   <img src=".\figures\p5.png" alt="image-20220104205322580" style="zoom: 33%;" />

   解决方案：将Wrapping方式由`REPEAT`改为`GL_CLAMP_TO_EDGE`效果会稍好一些，不过也不能完全避免。另一种可能的方式是采用球面贴图去实现，但因为时间有限，就没有实现。



2. 代码整合的时候发现天空盒会随着camera而移动，这样呈现出来的效果是很奇怪的，而且很可能camera前进到一定程度的时候就到了天空盒外面（比如下图），后来debug出来的原因是在主程序调用`drawSkybox()`绘制天空盒将`camera.getView()`作为`view`参数传入，相当于`skybox`的渲染管线进行了一次`shaderProgram.setUniformValue("view", camera.getView()`操作，结果就是观察天空盒的视角就是camera观察到的视角，解决方案是在`drawSkybox()`中不需要`view`参数。

   <img src=".\figures\p8.png" alt="image-20220104210045577" style="zoom: 33%;" />

   （在结束这个debug之后又对着色器和星球的大小进行了调整，所以呈现出来的效果不太一样）

   

3. 整合代码的以后一开始是很混乱的，因为开始大家没有很明确的“解耦合”的概念，都在主程序用不同的着色器实现，但不同的着色器存在不同的顶点数据和纹理，调用之后一个模型会绑定的数据缓存会影响另一个，这时候体会到`bind()`和`release()`的意义。之后我们在各自部分`draw()`函数中就知道了需要先绑定着色器，使用完之后要进行解绑，有点像操作系统中的“锁”的概念。

   

4. 与上面一点比较相似，也是因为大家对概念理解得不够深入造成的。OpenGL是一个状态机，状态设定之后会一直保持，比如深度测试，在绘制行星的`init()`函数中关闭了深度测试，后来也没有再注意就以为是默认开启，导致绘制球体时一直出bug。解决方案是我们再需要开启/关闭什么设置的时候用完要将其相应的关闭/开启，确保自己部分的代码不会影响到其他的显示。

   

   

### 5. 其他工作

- 代码整合
- 视频制作及项目展示
- 小组报告



### 6. 实验感想

虽然这次对于这个项目代码上的贡献不算多，但也是一直参与了项目过程，这次合作的经历还是比较愉快的，尽管中途出现了很多奇妙的bug，但最后大家都会为成功解决一个奇奇怪怪的bug而开心。而且也进一步感受到了小组合作的意义，很多时候并不是把自己的那部分完成好了就可以，还需要考虑自己的代码不会影响到他人的代码，以及如何与其他人的代码结合起来一起显示。
